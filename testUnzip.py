from zipfile import ZipFile
from addressArray import array
from PIL import Image
from PIL.ExifTags import TAGS
from monthDictionary import monthDictionary
import os
import sys

# returns a full address from the array of addresses in addressArray.py (array) that has a
# street number that matches the passed number. If there are multiple addresses in array
# that start with the same street number, the user is prompted to select the address that
# they want to use
def returnFullAddress(streetNumber):
    if streetNumber == "cancel":
        sys.exit("\nCanceled by user")

    # array to accumalate matching addresses
    matches = []

    # iterates through the array looking for addresses that have a street number that matches the input
    for address in array:
        # address.split(" "[0]) isolates the street number from the current address "selected"
        # in the array of addresses
        if address.split(" ")[0] == streetNumber:
            matches.append(address)
    
    # number of matches logic
    if len(matches) == 0:
        print("\nThere are no addresses with this street number")
        retry = input("Enter the street number (enter \"cancel\" to exit): ")

        # recursion
        return returnFullAddress(retry)
    
    # if there is only one match, return it
    elif len(matches) < 2:
        return matches[0]
    else:
        print("\nThere are multiple addresses with this street number: {}".format(matches))
        selector = None

        # making sure the number inputted by the user corresponds to one of the matching addresses i.e. 1 for the first match
        # 2 for the second, etc.

        # selector is the *valid* option picked by the user. userInput is the possibly invalid option picked.
        # if userInput passes the check, it is set as the value of selector
        while selector == None:
            userInput = int(input("Select one of the matches by entering the corresponding number \"1\" for the first option, \"2\" for the second, etc: "))
            if (userInput) == "cancel":
                sys.exit("Canceled by user")
            elif (userInput > 0 and userInput <= len(matches)):
                selector = userInput
            else:
                print("\nEnter a valid number (enter \"cancel\" to exit)")

        return(matches[selector-1])


# returns a writen date based on the metadata of the image file whose path is passed as an argument
def extractDateTime(filepath):
    img = Image.open(filepath)

    if not(306 in img.getexif()):
        sys.exit("no metadata, rename folder manually")
    print("Raw date: " + img.getexif()[306])
    rawDate = img.getexif()[306]

    # "rawDate.split(":")[1]" outputs the month part of the raw date (e.g. the 07 from 2023:07:13 14:37:25)
    # monthDictionary has these two digit codes as keys to values which are the month names that correspond to these codes
    # e.g. {"02": February}
    Month = monthDictionary[rawDate.split(":")[1]]
    # there has to be a better way to do this
    Day = rawDate.split(" ")[0].split(":")[2]
    Year = rawDate.split(" ")[0].split(":")[0]

    processedDate = "{} {}, {}".format(Month, Day, Year)

    print("Processed date: " + processedDate)
    return processedDate

# returns the file path for the first image in the folder whose file path
# is passed as an argument
def getFirstImagePath():
    print("\nFiles in folder: {}".format(os.listdir("./tempFolderName")))
    filename = os.listdir("./tempFolderName")[0]
    print("File selected: " + os.listdir("./tempFolderName")[0])

    print("Filepath returned: ./tempFolderName/{}".format(filename))
    return "./tempFolderName/{}".format(filename)

# makes a folder that the files in the zip folder corresponding to "filepath"
# are extracted to
# NB: this method must be called before getFirstImagePath in the code, as it creates
# the folder in the working directory whose path is used in getFirstImagePath
def extractFiles(filepath):
    os.mkdir("./tempFolderName")
    with ZipFile(filepath) as zObject:
        zObject.extractall("./tempFolderName")
    
# based on address and image metadata, assembles a suitable name for the
# folder of extracted images
# the date used is from the metadata of the first image in the folder
# the address is selected by the user inputting the street number of the desired address
def returnFolderName():
    extractFiles(input("\n\n\ninput image zip folder file path: ")[1:-1])
    
    streetAddress = returnFullAddress(input("\n\n\nEnter the street number: "))
    date = extractDateTime(getFirstImagePath())

    print("\nStreet address used: "+ streetAddress)
    print("Date: " + date)
    
    folderName = "{} - {}".format(streetAddress, date)
    print("\n\nFolder name: " + folderName)
    return folderName

# renames the folder to the name generated by newFolderName
def renameFolder():
    newFolderName = returnFolderName()
    os.rename("./tempFolderName", newFolderName)



renameFolder()


# getImageInfo(r"C:\Users\benjw\Downloads\Photos-001 (1).zip")

# right click the zip file to be unzipped and select "Copy as path"
# this is what is to be pasted into command prompt when prompted

# the slice [1:-1] gets rid of the quotes around the pasted file path, as the input method
# will add another pair of quotes around what is inputted, making ZipFile unable to read the path
# filePath = input("Enter the file path (with quotes): ")[1:-1]

# os.mkdir("./{}".format(address))

# with ZipFile(filePath) as zObject:
#     zObject.extractall(path="./extract output")
    # pastes unzipped folder into the command prompt working directory

